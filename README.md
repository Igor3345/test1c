Данный модуль представляет собой webpack сборщик, разделённый на части приспособленные для разработки на локальном сервере(в оперативной памяти аппаратного устройства) и на WS7(постоянном сервере).
И технической страницы на которой распологаются все основные компоненты в работоспособном состоянии.


Для начала работы необходимо склонировать данный репозиторий в рабочую папку с проектом. Данный модуль приспособлен для работы как на локальном сервере, так и на хосте,
поэтому разделять рабочие папки на дирректории для верстки и программирования не требуется. Исходные файлы для программирования и верстки одни и те же и хранятся в одной папке.

Команды для работы с модулем.

для разворота проекта. Установит все необходимые плагины и зависимости прописанные в package.json:

    $ yarn

для режима разработки. Соберет проект в оперативной памяти и откроет окно в браузере с получившимся результатом:

    $ yarn dev

Для сборки готового проекта. Данная команда применяется на WS&, в результате применения создаёт результирующий файл template.js и общий файл template_style.css, оба файль минифицированы.

    $ yarn build
  
Для работы на сервере WS7. Работа данной команды аналогична **yarn build**, но получившиеся файлы не сжимаются.

    $ yarn start

для сборки проекта в формате HTML + CSS + JS внутри папки dist, находящейся в той-же дирректории, что и папка исходник(src) применять команду

    $ yarn dist

Структура исходников фронтенда состоит из двух основных частей: **Styles** и **JS**.

#### 1. Styles

**Styles** выражена совокупностью ***.scss-файлов**.

исходники содержатся в директории **styles/**

  

Стили описаны в следующих основных файлах:

- **_custom.scss** - содержит переопределения bootstrap-фреймворка;
- **_fonts.scss** - содержит подключения необходимых для проекта шрифтов (как правило Google Fonts), а также иконочных шрифтов проекта (icomoon);
- **_variables.scss** - содержит дополнительные переменные проекта (вне bootstrap);
- **_mixins.scss** - содержит sass-миксины проекта;
- **_common.scss** - содержит общие стили и атомарные классы проекта;
- **_layout.scss** - содержит стили структуры страниц сайта;
- **_bems.scss** - основной файл, в котором ведется работа; в нем описываются стили блоков/компонентов сайта;
- **tech/** - директория, содержащая стили блоков с технической страницы; содержит в себе также папку **vendor/**, необходимую для стилизации соответствующих вендоров, подключаемых на проекте.
- **_spacing.scss** - содержит универсальную сетку отступов принятую в компании Individ. Данная сетка является адаптивной и перестраивается в соответствии с брэйкпоинтами bootstrap 5.

  

Общая точка подключения всех *.scss-файлов - **styles.scss**; именно из этого файла происходит сборка итогового template_styles.css.

#### 2. JS

**JS** выражена совокупностью **js-модулей**.

исходники содержатся в директории **js/template**

Скрипты описаны в структуре 2-х основных модулей:

1.  **indi** (содержит точку входа **index.js**, которая консолидирует в себе подключения всех модулей из папки **modules**) - этот модуль предназначен только для использования; код данного модуля не должен редактироваться.
2.  **template** (содержит точку входа **index.js**, в которой подключаются блоки функциональности из папки **modules**, необходимые для отработки на страницах сайта) - этот модуль содержит код непосредственного проекта; может активно изменяться/масштабироваться;

- через контроллер блоков загрузки **indiBlockController** блоки добавляются к выполнению на загружаемой странице методом **add()** в качестве его первого аргумента;
- при наличии на странице DOM-элемента, обозначенного вторым аргументом метода **add()** - выполняются;
- содержит также директорию **common/**, в которой описывается стартовый набор модулей, необходимых на каждом проекте.
- реализована функция инициализации скриптов у динамически добавленных элементов. Данные события навешаны на тэг **<body>**, поэтому вызов данных событий доступен из любого скриптового файла.
  

Для того, чтобы добавить **блок скрипта** в сборку, необходимо:

  

1.  в папке **template/modules/** скопировать заранее предусмотренный для этого модуль **moduleName.js**;
2.  задать необходимое имя полученной копии в Camel case стиле;
3.  продублировать название нового модуля внутри файла (export const **moduleName** ...);
4.  добавить понятное название блока внутри кавычек в начале файла модуля (Модуль **"..."**);
5.  описать код в теле экспортируемой функции модуля.

  

После этого в файле **template/index.js**:

  

-   с импортировать новый модуль:
	import {**moduleName**} from './modules/**moduleName**';

  

-   добавить его к загрузке в **indiBlockController** методом **add()** по соответствующему селектору:
	indiBlockController.add(**moduleName**, '**.js-module-name**');

  

Если требуется описать код, который должен выполняться **на всех страницах сайта**, его необходимо разместить в файле **template/index.js** после комментария: "_Общий функционал для всех страниц_".

  

Для **общих функций/объектов/классов**, которые могут быть необходимы в нескольких модулях проекта предусмотрен файл **utils.js**.

  

Что касается подключения **вендорных библиотек**, сборка предусматривает механизм **динамического импорта модулей**.

  

Чтобы подключить стороннюю библиотеку в нужный блок, необходимо:

  

-   добавить ключевое слово **async** перед объявлением функции модуля:
	export const moduleName = **async** () => { ... };

  

-   в теле функции модуля при помощи функции **import()** подключить необходимую библиотеку:
	**await import(/\* webpackChunkName: "****vendor-name****" \*/ '****vendor-name****');**

  

Важно! При подключении вендоров посредством **динамического импорта** необходимо, чтобы параметр **webpackChunkName** точно соответствовал **имени подключаемой библиотеки**.

  

Если подключаемая библиотека использует **экспорт по умолчанию**, то необходимо получать значение импорта через **деструктуризацию**:

  

const **{ default: vendorName }** = await import(/* webpackChunkName: "vendor-name" */ 'vendor-name');

  

и дальше использовать **vendorName** согласно документации библиотеки.

  

**Переинициализация**

  

Если требуется **переинициализировать** какой-либо js-блок (например после получения данных через ajax), то для этого необходимо просто:

  

1.  подключить **indiBlockController** из **indi-модуля**;
2.  вызвать метод **init()** передав ему в качестве параметра соответствующий нужному блоку **селектор**.

  

Также предусмотрена возможность переинициализации **всех** js-блоков контроллера посредством вызова метода **indiBlockController.initAll();**

  

Файл **template/index.js** является общей точкой входа, из которого собирается итоговый template.js, а также **chunk-файлы вендоров**, подгружаемых на страницу динамически **при необходимости**.

Чтобы инициализировать скрипты у блоков, которые были добавлены после прогружения DOM дерева(тэга <body>) нужно воспользоваться функциями reInitBlock и reInitBlocks.
**Первый вариант** нужно использовать в случае, если нужно проверить инициализацию скриптов внутри **1** блока. Пример:
**document.querySelector('body').dispatchEvent(new CustomEvent('reInitBlock', {detail:{classNames:".header"}}))**
В данной случае будет проанализирован тэг с классом header и в случае, если на каком-либо элементе, не будут проинициализированы скрипты, будет произведена инициализация.
**Второй вариант** нужно использовать в случае, если нужно проверить инициализацию скриптов внутри **2>=** блоков. Пример:
**document.querySelector('body').dispatchEvent(new CustomEvent('reInitBlocks', {detail:{classNames:".header"}}))**
В данном случае будут найдены и проврены все тэги с классами **header**.
**document.querySelector('body').dispatchEvent(new CustomEvent('reInitBlocks', {detail:{classNames:[".header", ".footer"]}}))**
В данном случае будут проверены все элементы внутри тэгов с классами **header** и **footer**.

#### 3. SVG

В новой версии модуля было принято решение перейти с иконочного шрифта на SVG спрайты. Спрайт создаётся автоматически. В папке images есть папка sprites
в неё нужно помещать все картинки формата svg из которох будет собран спрайт. Сборка спрайта происходит при прогрузке DOM дерева и инициализации скриптов.
Собранный скрипт называется sprite_build.svg